variables:
  GIT_SUBMODULE_STRATEGY: recursive
  RUNNER_ENV: stage
  DEPT: fsw
  PROJECT: augustus
  CLUSTER: heavyweight
  PETALINUX_VER: '2021.2'
  VITIS_VER: '2021.2'

  PIPELINE_TOOLS_REPO_URL: 'https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.maxar.com/maxar/pipeline-tools.git'
  PIPELINE_TOOLS_BRANCH: 'main'
  PIPELINE_TOOLS_CLONE_DIR: 'pipeline_tools'

# availble cluster types as-of 6/2024
# lightweight
# mediumweight
# heavyweight

##################################################
# ANCHOR - pipeline-tools-setup - Provide tags, dependencies and before script for any pipeline job
#
.pipeline-tools-setup: &pipeline-tools-setup
  before_script:
    - rm -rf ${PIPELINE_TOOLS_CLONE_DIR}
    - echo "git clone --depth 1 -b ${PIPELINE_TOOLS_BRANCH} ${PIPELINE_TOOLS_REPO_URL} ${PIPELINE_TOOLS_CLONE_DIR}"
    - git clone --depth 1 -b ${PIPELINE_TOOLS_BRANCH} ${PIPELINE_TOOLS_REPO_URL} ${PIPELINE_TOOLS_CLONE_DIR}
    - cd ${PIPELINE_TOOLS_CLONE_DIR}
    - pip install -r requirements.txt

workflow:
  rules:
    - if: '$CI_COMMIT_BRANCH && $CI_OPEN_MERGE_REQUESTS'
      when: never
    - if: $RUNNER_ENV == 'dev'
      variables:
        AWS_REGISTRY: $AWS_DEV_REGISTRY
    - if: $RUNNER_ENV == 'stage'
      variables:
        AWS_REGISTRY: $AWS_STAGE_REGISTRY
    - if: $RUNNER_ENV == 'prod'
      variables:
        AWS_REGISTRY: $AWS_PROD_REGISTRY
    - when: never

stages:
  - build
  - test-prepare
  - test
  - release 
  - quality
  - package
  - images

mend:
  <<: *pipeline-tools-setup
  rules:
    - if: '$CI_COMMIT_BRANCH == "development"'
  image: docker.artpro.digitalglobe.com:443/python:3.9
  needs: []
  stage: quality
  tags:
    - env=$RUNNER_ENV
    - project=$PROJECT
    - dept=$DEPT
    - cluster=$CLUSTER
    - arch=amd64
  variables:
    PROJECT_NAME: Augustus_Core
    WHITESOURCE_SCRIPT: ${PIPELINE_TOOLS_CLONE_DIR}/scanning/whitesource_base.py
    WHITESOURCE_ARGS: --project-name ${PROJECT_NAME} --artifact-path ${PIPELINE_TOOLS_CLONE_DIR}/artifacts --includes src/ --excludes pipeline/**
  script:
    - apt-get update && apt-get install default-jdk-headless -y
    - cd ${CI_PROJECT_DIR}
    - python -m venv .venv
    - source .venv/bin/activate
    - pip install boto3 paramiko requests
    - echo "python ${WHITESOURCE_SCRIPT} ${WHITESOURCE_ARGS}"
    - python ${WHITESOURCE_SCRIPT} ${WHITESOURCE_ARGS}
  artifacts:
    paths:
      - ${PIPELINE_TOOLS_CLONE_DIR}/artifacts/*
    expire_in: 4 weeks
  allow_failure: true
  
checkmarx:
  <<: *pipeline-tools-setup
  rules:
    - if: '$CI_COMMIT_BRANCH == "development"'
  image: docker.artpro.digitalglobe.com:443/python:3.9
  needs: []
  stage: quality
  variables:
    SOURCE_DIR: ${CI_PROJECT_DIR}
    CX_PRESET: OWASP TOP 10 - 2017
    CX_EXCLUDE_FILE_TYPES: html,js,json,css,ada,adb,ads,gpj,jpg,png,gif
    KUBERNETES_SERVICE_ACCOUNT: cicd
    PROJECT_NAME: Augustus_Core
  tags:
    - env=$RUNNER_ENV
    - project=$PROJECT
    - dept=$DEPT
    - cluster=$CLUSTER
    - arch=amd64
  script:
    - apt-get update && apt-get install -y ca-certificates && rm -rf /var/lib/apt/lists/*
    - wget https://github.digitalglobe.com/raw/enterprise-core-services/public-certificates/master/Maxar-CA-Chain.crt
    - cp Maxar-CA-Chain.crt /usr/local/share/ca-certificates
    - update-ca-certificates
    - export REQUESTS_CA_BUNDLE=/etc/ssl/certs/ca-certificates.crt
    - echo "python scanning/checkmarx.py --source-dir \"${SOURCE_DIR}\" --special-exclude-files \"\" --exclude-dir \"\" --mainrepo ${PROJECT_NAME} --cx-preset \"${CX_PRESET}\" --include-folders \"${CX_INCLUDE_FOLDERS}\" --exclude-file-types \"${CX_EXCLUDE_FILE_TYPES}\" --gen-pdf-on-stat-fail True --gituser ${GITLAB_USER_LOGIN}"
    - python scanning/checkmarx.py --source-dir "${SOURCE_DIR}" --special-exclude-files "" --exclude-dir "" --mainrepo ${PROJECT_NAME} --cx-preset "${CX_PRESET}" --include-folders "${CX_INCLUDE_FOLDERS}" --exclude-file-types "${CX_EXCLUDE_FILE_TYPES}" --gen-pdf-on-stat-fail True --gituser ${GITLAB_USER_LOGIN}
  artifacts:
    paths:
      - ${PIPELINE_TOOLS_CLONE_DIR}/reports/*
    expire_in: 4 weeks

build-cfs:
  stage: build
  image: $IMAGE
  script:
    - source /etc/profile.d/settings64-Vitis.sh || true
    - if [[ $BUILD_ARCH == amd64 && $(uname -m) == x86_64 ]]; then export BUILD_ARGS="SIMULATION=native"; fi
    - if [[ $BUILD_ARCH == aarch64 ]]; then export BUILD_ARGS="O=build-${BUILD_ARCH} SIMULATION=${BUILD_ARCH}-linux-gnu SBNCONF=prod STARHIL=true"; fi
    - if [[ $BUILD_ARCH == riscv32 ]]; then export BUILD_ARGS="O=build-${BUILD_ARCH} SIMULATION=${BUILD_ARCH}-llp-freertos CPULIST=llp-proto SBNCONF=prod"; fi
    
    - make $BUILD_ARGS --jobs --output-sync install 

    # package up CFEs
    - pushd build*
    - |
        set -x
        for f in exe/*; do
            CFE_NAME=$(basename $f)
            echo $f
            mkdir opt
            cp -R $f opt/cfs
            cp ftl.env opt/ftl.env > /dev/null 2>&1
            tar cvzf $CFE_NAME.tgz opt
            rm -rf opt
        done
    - popd

  variables:
    IMAGE: $AWS_REGISTRY/irad/augustus/vitis:$VITIS_VER

  parallel:
    matrix:
      - BUILD_ARCH: 'amd64'
      - BUILD_ARCH: 'aarch64'
      - BUILD_ARCH: 'riscv32'
        IMAGE: $AWS_REGISTRY/irad/augustus/riscv

  tags:
    - env=$RUNNER_ENV
    - project=$PROJECT
    - dept=$DEPT
    - cluster=$CLUSTER
    - arch=amd64

  artifacts:
    paths:
      - 'build*/exe'
      - 'build*/ftl.env'
      - 'build*/*.tgz'
      - 'petalinux/*.bb'
    when: 'always'
    expire_in: 1 month

build-fs1:
  stage: build
  image: $IMAGE
  script:
    - source /etc/profile.d/settings64-Vitis.sh || true
    - if [[ $BUILD_ARCH == amd64 && $(uname -m) == x86_64 ]]; then export BUILD_ARGS="SIMULATION=native STARHIL=true"; fi
    - if [[ $BUILD_ARCH == aarch64 ]]; then export BUILD_ARGS="O=build-${BUILD_ARCH} SIMULATION=${BUILD_ARCH}-linux-gnu SBNCONF=prod STARHIL=true"; fi
    - if [[ $BUILD_ARCH == riscv32 ]]; then export BUILD_ARGS="O=build-${BUILD_ARCH} SIMULATION=${BUILD_ARCH}-llp3-freertos CPULIST=llp-proto SBNCONF=prod"; fi
    
    - make MISSIONCONFIG=FS1 $BUILD_ARGS --jobs --output-sync install 

    # package up CFEs
    - pushd build*
    - |
        set -x
        for f in exe/*; do
            CFE_NAME=$(basename $f)
            echo $f
            mkdir opt
            cp -R $f opt/cfs
            cp ftl.env opt/ftl.env > /dev/null 2>&1
            tar cvzf $CFE_NAME.tgz opt
            rm -rf opt
        done
    - popd

  variables:
    IMAGE: $AWS_REGISTRY/irad/augustus/vitis:$VITIS_VER

  parallel:
    matrix:
      - BUILD_ARCH: 'amd64'
      - BUILD_ARCH: 'aarch64'
      - BUILD_ARCH: 'riscv32'
        IMAGE: $AWS_REGISTRY/irad/augustus/riscv

  tags:
    - env=$RUNNER_ENV
    - project=$PROJECT
    - dept=$DEPT
    - cluster=$CLUSTER
    - arch=amd64

  artifacts:
    paths:
      - 'build*/exe'
      - 'build*/ftl.env'
      - 'build*/*.tgz'
      - 'petalinux/*.bb'
    when: 'always'
    expire_in: 1 month

build-ground:
  stage: build
  image: $AWS_REGISTRY/irad/augustus/vitis:$VITIS_VER
  script:
    - source /etc/profile.d/settings64-Vitis.sh
    - if [[ $BUILD_ARCH != amd64 ]]; then export CC=$XILINX_VITIS/gnu/$BUILD_ARCH/lin/$BUILD_ARCH-linux/bin/$BUILD_ARCH-linux-gnu-gcc; fi

    # build cmdUtil
    - pushd tools
    - pushd cfs_ground_system/Subsystems/cmdUtil
    - make --jobs --output-sync
    - popd

    # cmdUtil archive
    - mkdir -p usr/local/bin
    - cp cfs_ground_system/Subsystems/cmdUtil/cmdUtil usr/local/bin
    - tar --exclude-vcs -cvzf $CI_PROJECT_DIR/cmdutil.$BUILD_ARCH.tgz usr
    - rm -rf usr

    # cfs ground archive
    - mkdir -p opt
    - cp -R cfs_ground_system opt
    - tar --exclude-vcs -cvzf $CI_PROJECT_DIR/cfs-ground.$BUILD_ARCH.tgz opt
    - rm -rf opt
  artifacts:
    paths:
      - '*.tgz'
    when: 'always'
    expire_in: 1 month

  parallel:
    matrix:
      - BUILD_ARCH: [ 'amd64', 'aarch64' ]

  tags:
    - env=$RUNNER_ENV
    - project=$PROJECT
    - dept=$DEPT
    - cluster=$CLUSTER
    - arch=amd64

build-doc:
  rules:
    - if: '$CI_COMMIT_BRANCH == "development"'
  stage: build
  image: $AWS_REGISTRY/irad/augustus/vitis:$VITIS_VER
  before_script:
    - apt-get update && apt-get install -y doxygen
  script:
    - source /etc/profile.d/settings64-Vitis.sh
    
    - make O=build-doc doc

  tags:
    - env=$RUNNER_ENV
    - project=$PROJECT
    - dept=$DEPT
    - cluster=$CLUSTER
    - arch=amd64

  artifacts:
    paths:
      - 'build-doc/docs'
    when: 'always'
    expire_in: 1 month

release:
  rules:
    - if: '$CI_COMMIT_BRANCH == "development"'  
  stage: release
  image: $AWS_REGISTRY/irad/augustus/vitis:$VITIS_VER
  dependencies:
    - build-cfs
  script:
    - |-
          if [[ $CI_COMMIT_BRANCH == 'development' ]]; then
              pushd $CI_PROJECT_DIR/..
              git config --global user.email "zynqmp@maxar.gitlab"
              git config --global user.name "ci-bot"
              git clone https://gitlab-ci-token:${RELEASE_ACCESS_TOKEN}@gitlab.maxar.com/irad/augustus/release-zynqmp.git
              popd
              pushd $CI_PROJECT_DIR
              tar czvf build-aarch64.tar.gz build-aarch64
              mv build-aarch64.tar.gz $CI_PROJECT_DIR/../release-zynqmp/cfs
              popd
              pushd $CI_PROJECT_DIR/../release-zynqmp
              git add .
              git commit -m "Release CFS $CI_COMMIT_SHORT_SHA $CI_COMMIT_TIMESTAMP"
              git pull
              git push origin HEAD:main
              popd
          else
              echo "No push to release on branch $CI_COMMIT_BRANCH, only on development..."
          fi
  tags:
    - env=$RUNNER_ENV
    - project=$PROJECT
    - dept=$DEPT
    - cluster=$CLUSTER
    - arch=amd64

release-fs1:
  rules:
    - if: '$CI_COMMIT_BRANCH == "development"'  
  stage: release
  image: $AWS_REGISTRY/irad/augustus/vitis:$VITIS_VER
  dependencies:
    - build-fs1
  script:
    - |-
          if [[ $CI_COMMIT_BRANCH == 'development' ]]; then
              pushd $CI_PROJECT_DIR/..
              git config --global user.email "zynqmp@maxar.gitlab"
              git config --global user.name "ci-bot"
              git clone https://gitlab-ci-token:${RELEASE_ACCESS_TOKEN}@gitlab.maxar.com/irad/augustus/release-zynqmp.git
              popd
              pushd $CI_PROJECT_DIR
              tar czvf build-aarch64-fs1.tar.gz build-aarch64
              mv build-aarch64-fs1.tar.gz $CI_PROJECT_DIR/../release-zynqmp/cfs
              popd
              pushd $CI_PROJECT_DIR/../release-zynqmp
              git add .
              git commit -m "Release CFS FS1 $CI_COMMIT_SHORT_SHA $CI_COMMIT_TIMESTAMP"
              git pull
              git push origin HEAD:main
              popd
          else
              echo "No push to release on branch $CI_COMMIT_BRANCH, only on development..."
          fi
  tags:
    - env=$RUNNER_ENV
    - project=$PROJECT
    - dept=$DEPT
    - cluster=$CLUSTER
    - arch=amd64

understand-test:
  needs: []
  stage: test
  variables:
    IMAGE_REGISTRY: 339632996350.dkr.ecr.us-gov-west-1.amazonaws.com
    IMAGE_NAME: spd-pipeline-scitools-understand
    IMAGE_TAG: augustus-pipeline-license
  image: $IMAGE_REGISTRY/$IMAGE_NAME:$IMAGE_TAG
  tags:
    - env=$RUNNER_ENV
    - project=$PROJECT
    - dept=$DEPT
    - cluster=$CLUSTER
    - arch=amd64
  before_script:
    - /usr/bin/register_understand_license
  script:
    - und settings -db tools/understand/cfs.und
    - und add -db tools/understand/cfs.und .
    - und analyze -db tools/understand/cfs.und
    - und analyze -db tools/understand/cfs.und
    - und codecheck -flattentree -db tools/understand/cfs.und tools/understand/AugustusAUTOSARMISRA.json .
    - echo "tada"
  after_script:
    - und -deregisterlicensecode
  artifacts:
    paths:
      - CodeCheckResultByFile.txt
      - CodeCheckResultByTable.csv
      - CodeCheckResultByViolation.txt
    expire_in: 2 weeks
  when:
    manual

# test-prepare
# Prepares list of tests to prepare
# TODO do we exclude tests here or later
test-prepare:
  needs: []
  image: $AWS_REGISTRY/irad/augustus/vitis:$VITIS_VER
  stage: test-prepare
  script:
    - echo "Discovering tests . . ."
    - mkdir -p test_batches
    - cd tools/SIL-studio
    # Get the list of test files, exclude the necessary ones, and sort them
    - find test_scripts -type f -name '*.py' | python3 ../script/exclude_tests.py software | sort > all_tests.txt
    # Get the total number of tests
    - TOTAL_TESTS=$(wc -l < all_tests.txt)
    # Calculate the number of lines per batch, ensuring at least 1 line per batch
    - LINES_PER_BATCH=$(( (TOTAL_TESTS + 5) / 6 ))  # +5 ensures rounding up
    # Split the test files into batches
    - split -d -a 2 -l $LINES_PER_BATCH all_tests.txt batch_
    # Ensure there are exactly 6 batch files
    - for i in $(seq -w 0 5); do touch $(printf "batch_%02d" $i); done
    # Move batch files to test_batches directory
    - mv batch_* ../../test_batches/
  tags:
    - env=$RUNNER_ENV
    - project=$PROJECT
    - dept=$DEPT
    - cluster=lightweight
    - arch=amd64
  artifacts:
    paths:
      - test_batches/

regression-test:
  needs: [test-prepare]
  stage: test
  image: $AWS_REGISTRY/irad/augustus/vitis:$VITIS_VER
  script:
    - git config --global --add safe.directory /builds/irad/augustus/fsw/cfs
    - echo "Running test batch $CI_NODE_INDEX"
    # Adjust the index to start from 0
    - ADJUSTED_INDEX=$((CI_NODE_INDEX - 1))
    - BATCH_FILE=$(printf "test_batches/batch_%02d" $ADJUSTED_INDEX)
    - tools/script/run_tests_sw_imp_mk2.sh "$BATCH_FILE"    
  parallel: 6
  tags:
    - env=$RUNNER_ENV
    - project=$PROJECT
    - dept=$DEPT
    - cluster=heavyweight
    - arch=amd64
  artifacts:
    paths:
      - tools/SIL-studio/outputs
    when: always
  timeout: 3h
  when:
    always


# Passes filename as variable to sil-studio to run regression test.
# Accessed through web interface.
# 1. Click pipeline in your commit
# 2. Click the job 'regression-test-single'
# 3. key: test_scr  value: filename.py
# 3a. Where filename.py is the filename of your test.  Case sensitive.
regression-test-single:
  needs: []
  stage: test
  image: $AWS_REGISTRY/irad/augustus/vitis:$VITIS_VER
  script:
    - git config --global --add safe.directory /builds/irad/augustus/fsw/cfs
    - tools/script/run_single_launcher.sh
  tags:
    - env=$RUNNER_ENV
    - project=$PROJECT
    - dept=$DEPT
    - cluster=heavyweight
    - arch=amd64
  artifacts:
    paths:
      - tools/SIL-studio/outputs
    when: always
  timeout: 3h
  when:
    manual

regression-test-legacy:
  needs: []
  stage: test
  image: $AWS_REGISTRY/irad/augustus/vitis:$VITIS_VER
  script:
    - sudo ln -sf /usr/local/bin/python3.10 /usr/local/bin/python3
    - sudo ln -sf /usr/local/bin/python3.10 /usr/local/bin/python
    - sudo ln -sf /usr/local/bin/python3.10 /usr/bin/python3
    - sudo ln -sf /usr/local/bin/python3.10 /usr/bin/python
    - sudo ln -s /sbin/ifconfig /usr/sbin/ifconfig
    - echo "Checking out respositories"
    - mkdir -p ../sim_core ../vor-mon
    - git clone https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.maxar.com/irad/augustus/sim/nfp/sil/sim_core.git ../sim_core
    - git clone https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.maxar.com/irad/augustus/boards/vor-mon.git ../vor-mon
    - echo "Changing file ownershp"
    - sudo chown -R dev:dev /builds/irad/augustus/fsw/cfs
    - sudo chown -R dev:dev ../sim_core
    - sudo chown -R dev:dev ../vor-mon
    - echo "Build CFS"
    - git config --global --add safe.directory /builds/irad/augustus/fsw/cfs
    - git submodule update --init --recursive
    - make SIMULATION=native MISSIONCONFIG=FS1 prep
    - make -j
    - make install
    - echo "Build sim_core"
    - |
      (
        cd ../sim_core && \
        git checkout $CI_COMMIT_REF_NAME || true
        git branch --show-current
        git submodule update --init --recursive && \
        make prep && \
        make -j && \
        make install
      )
    - echo "Build vor-mon"
    - |
      (
        cd ../vor-mon && \
        git checkout $CI_COMMIT_REF_NAME || true
        git branch --show-current
        make CC=gcc-10 allnix
      )
    - echo "TEST TIME"
    - cd tools/SIL-studio
    - /usr/bin/python3 -m pip install -r requirements.txt
    - cp ../script/run_tests_sw_imp.sh run_tests_sw_imp.sh
    - ./run_tests_sw_imp.sh   
  tags:
    - env=$RUNNER_ENV
    - project=$PROJECT
    - dept=$DEPT
    - cluster=heavyweight
    - arch=amd64
  artifacts:
    paths:
      - tools/SIL-studio/outputs
    when: always
  timeout: 3h
  when:
    # TODO RESET TO always
    manual
    
regression-test-hardware:
  needs: []
  stage: test
  resource_group: regression-test-hardware_single_execution_group
  image: $AWS_REGISTRY/irad/augustus/riscv
  variables:
    TEST_MODE: "HIL"
  script:
    - cd /builds/irad/augustus/fsw/cfs
    - pwd
    - tar czvf /builds/irad/augustus/repo.tar.gz .
    - file /builds/irad/augustus/repo.tar.gz
    - sshpass -p $NUC_PASSWORD ssh -o StrictHostKeyChecking=no $NUC_USER@$NUC_IP "mkdir /home/gsds/pipeline/repo/"    
    - sshpass -p $NUC_PASSWORD scp -o StrictHostKeyChecking=no /builds/irad/augustus/repo.tar.gz $NUC_USER@$NUC_IP:/home/gsds/pipeline/repo
    - sshpass -p $NUC_PASSWORD ssh -o StrictHostKeyChecking=no $NUC_USER@$NUC_IP "tar -xvzf /home/gsds/pipeline/repo/repo.tar.gz -C /home/gsds/pipeline/repo/"    
    - sshpass -p $NUC_PASSWORD ssh -o StrictHostKeyChecking=no $NUC_USER@$NUC_IP "/home/gsds/pipeline/repo/tools/script/sil_launcher.sh"
    - sshpass -p $NUC_PASSWORD scp -o StrictHostKeyChecking=no $NUC_USER@$NUC_IP:/home/gsds/pipeline/hil_log/log_archive.zip hil_archive.zip
  after_script:
    - sshpass -p $NUC_PASSWORD ssh -o StrictHostKeyChecking=no $NUC_USER@$NUC_IP "rm /home/gsds/pipeline/hil_log/log_archive.zip"
    - sshpass -p $NUC_PASSWORD ssh -o StrictHostKeyChecking=no $NUC_USER@$NUC_IP "rm -rf /home/gsds/pipeline/repo"

  tags:
    - env=$RUNNER_ENV
    - project=$PROJECT
    - dept=$DEPT
    - cluster=heavyweight
    - arch=amd64
  artifacts:
    paths:
      - 'hil_archive.zip'
  when:
    manual

unit-test:
  needs: []
  stage: test
  image: $AWS_REGISTRY/irad/augustus/vitis:$VITIS_VER
  script:    
    - make SIMULATION=native ENABLE_UNIT_TESTS=true ARCH=native/default_llp -j all
    - make ARCH=native/default_llp -j test
    - make ARCH=native/default_llp lcov

  tags:
    - env=$RUNNER_ENV
    - project=$PROJECT
    - dept=$DEPT
    - cluster=heavyweight
    - arch=amd64

  artifacts:
    paths:
      - '**/lcov'
      - '**/Testing/Temporary/*.log'
    when: 'always'
    expire_in: 1 week

acceptance-tests:
  stage: test
  image: $AWS_REGISTRY/irad/augustus/vitis:$VITIS_VER
  script:
    - |
      if echo "$CI_COMMIT_MESSAGE" | grep -q "\[VERBOSE\]"; then 
          FLAG="-v"; 
      elif echo "$CI_COMMIT_MESSAGE" | grep -q "\[VERY_VERBOSE\]"; then 
          FLAG="-vv"; 
      else 
          FLAG="-s"; 
      fi
      echo "Start: $TEST_TYPE acceptance test, verbosity level $FLAG"
      cd tests/$TEST_FOLDER
      python3 ../../../tools/acceptance_runner/acceptanceRunner.py $FLAG
      if [ $? -eq 0 ]
          then
            echo "$TEST_TYPE test passed"
          else
            echo "$TEST_TYPE test failed"
      fi
      echo "End: $TEST_TYPE acceptance test"
  allow_failure: false
  timeout: 60m
  parallel:
    matrix:
      - TEST_TYPE: "Latency_app"
        TEST_FOLDER: "latency/llp"
      - TEST_TYPE: "Hello_CFS"
        TEST_FOLDER: "hello_cfs/llp"
  tags:
    - env=$RUNNER_ENV
    - project=$PROJECT
    - dept=$DEPT
    - cluster=$CLUSTER
    - arch=amd64

package-petalinux:
  stage: package
  image: $AWS_REGISTRY/irad/augustus/petalinux:$PETALINUX_VER
  needs: [build-cfs]
  script:
    - source ~/petalinux/settings.sh
    - pushd petalinux
    - ./package.sh cfs $CFE_NAME ./xilinx-zcu102-v$PETALINUX_VER-final.bsp build-aarch64
  timeout: 1h 30m

  parallel:
    matrix:
      - CFE_NAME: [ llp, hlp, combined ]

  artifacts:
    paths:
      - 'petalinux/**/build/*.log'
      - 'petalinux/**/images'
      - 'petalinux/**/cfs'
    when: 'always'
    exclude:
      - 'petalinux/**/images/linux/vmlinux'
    expire_in: 1 month

  tags:
    - env=$RUNNER_ENV
    - project=$PROJECT
    - dept=$DEPT
    - cluster=heavyweight
    - arch=amd64

.image-builder: &image-builder
  before_script:
    # login to the registry
    - aws ecr get-login-password --region $AWS_REGION |
        docker login
            --username AWS
            --password-stdin $AWS_REGISTRY

    # make sure git describe will work
    - git fetch --recurse-submodules=no --deepen 1000
  timeout: 1h 30m

  tags:
    - env=$RUNNER_ENV
    - project=$PROJECT
    - dept=$DEPT
    - cluster=$CLUSTER
    - arch=amd64

  artifacts:
    paths:
      - 'image*.env'
    when: 'always'
    expire_in: 1 month

image-cfs:
  <<: *image-builder
  needs: [ build-cfs, package-petalinux ]
  stage: images
  image: $AWS_REGISTRY/irad/augustus/tools:ci-tools
  script:
    # metadata vars
    - export IMAGE_TITLE="Augustus FSW"
    - export IMAGE_DESCRIPTION="Augustus FSW for $CFE_NAME"
    - export IMAGE_CREATED=`date -u +'%Y-%m-%dT%H:%M:%SZ'`
    - export IMAGE_SOURCE="${CI_PROJECT_URL}"
    - export IMAGE_REVISION="${CI_COMMIT_SHA}"
    - export IMAGE_VERSION=$(git describe --abbrev=8 | sed 's/+/_/g')
    - export PROGRAM_NAME="augustus"
    - export VEHICLE_NAME="augustus"
    - export DATABASE_VERSION="none"

    - export IMAGE_NAME_BASE=irad/augustus/fsw/${CFE_NAME}
    - export IMAGE_NAME=${AWS_REGISTRY}/${IMAGE_NAME_BASE}:${IMAGE_VERSION}

    # make sure the repository exists that we're going to push to
    - aws ecr create-repository --repository-name $IMAGE_NAME_BASE || true

    # build the arm64v8 image directly from the petalinux rootfs
    - ./docker/docker-build.sh
        linux/arm64v8
        $CFE_NAME
        scratch
        $IMAGE_NAME-arm64v8
        main
        petalinux/$CFE_NAME/images/linux/rootfs.tar.gz

    # build the amd64 image on top of an ordinary base image
    - ./docker/docker-build.sh
        linux/amd64
        $CFE_NAME
        public.ecr.aws/docker/library/ubuntu:20.04
        $IMAGE_NAME-amd64
        main
        build/$CFE_NAME.tgz

    # make a manifest image
    - echo "making manifest"
    - docker manifest create $IMAGE_NAME $IMAGE_NAME-amd64 $IMAGE_NAME-arm64v8
    - docker manifest inspect $IMAGE_NAME
    - docker manifest push 
        $IMAGE_NAME
        docker://$IMAGE_NAME

    # create an artifact with image info
    - echo "IMAGE_${CFE_NAME^^}=$IMAGE_NAME" >> images.${CFE_NAME}.env
    - cat images*.env

  parallel:
    matrix:
      - CFE_NAME: [ llp, hlp ]

image-ground:
  <<: *image-builder
  stage: images
  image: $AWS_REGISTRY/irad/augustus/tools:ci-tools
  needs: [ build-ground ]
  script:
    # metadata vars
    - export IMAGE_TITLE="$GND_PRODUCT"
    - export IMAGE_DESCRIPTION="Augustus $GND_PRODUCT"
    - export IMAGE_CREATED=`date -u +'%Y-%m-%dT%H:%M:%SZ'`
    - export IMAGE_SOURCE="${CI_PROJECT_URL}"
    - export IMAGE_REVISION="${CI_COMMIT_SHA}"
    - export IMAGE_VERSION=$(git describe --abbrev=8 | sed 's/+/_/g')
    - export PROGRAM_NAME="augustus"
    - export VEHICLE_NAME="augustus"
    - export DATABASE_VERSION="none"

    - IMAGE_PARENT_NAME=${AWS_REGISTRY}/irad/augustus/${GND_PRODUCT}:base
    - export IMAGE_NAME_BASE=irad/augustus/${GND_PRODUCT}
    - export IMAGE_NAME=${AWS_REGISTRY}/${IMAGE_NAME_BASE}:${IMAGE_VERSION}

    # make sure the repository exists that we're going to push to
    - aws ecr create-repository --repository-name $IMAGE_NAME_BASE || true

    # make images
    - ./docker/docker-build.sh 
        linux/amd64
        ""
        $IMAGE_PARENT_NAME-amd64
        $IMAGE_NAME-amd64
        $DOCKER_TARGET
        $GND_PRODUCT.amd64.tgz
    - ./docker/docker-build.sh 
        linux/arm64v8
        ""
        $IMAGE_PARENT_NAME-arm64v8
        $IMAGE_NAME-arm64v8
        $DOCKER_TARGET
        $GND_PRODUCT.aarch64.tgz

    # make a manifest image
    - echo "making manifest"
    - docker manifest create $IMAGE_NAME $IMAGE_NAME-amd64 $IMAGE_NAME-arm64v8
    - docker manifest inspect $IMAGE_NAME
    - docker manifest push 
        $IMAGE_NAME
        docker://$IMAGE_NAME

    # create an artifact with image info
    - echo "IMAGE_$(echo ${GND_PRODUCT^^} | sed 's/-/_/g')=$IMAGE_NAME" >> images.$GND_PRODUCT.env
    - cat images*.env

  parallel:
    matrix:
      - GND_PRODUCT: cfs-ground
        DOCKER_TARGET: base
      - GND_PRODUCT: cmdutil
        DOCKER_TARGET: main

image-sil-studio:
  <<: *image-builder
  stage: images
  image: $AWS_REGISTRY/irad/augustus/tools:ci-tools
  needs: [ ]
  script:
    # metadata vars
    - export IMAGE_TITLE="SIL Studio"
    - export IMAGE_DESCRIPTION="Augustus SIL Studio test runner"
    - export IMAGE_CREATED=`date -u +'%Y-%m-%dT%H:%M:%SZ'`
    - export IMAGE_SOURCE="${CI_PROJECT_URL}"
    - export IMAGE_REVISION="${CI_COMMIT_SHA}"
    - export IMAGE_VERSION=$(git describe --abbrev=8 | sed 's/+/_/g')
    - export PROGRAM_NAME="augustus"
    - export VEHICLE_NAME="augustus"
    - export DATABASE_VERSION="none"

    - IMAGE_PARENT_NAME=docker.artpro.digitalglobe.com:443/python:3.9
    - export IMAGE_NAME_BASE=irad/augustus/sil-studio
    - export IMAGE_NAME=${AWS_REGISTRY}/${IMAGE_NAME_BASE}:${IMAGE_VERSION}

    # make sure the repository exists that we're going to push to
    - aws ecr create-repository --repository-name $IMAGE_NAME_BASE || true

    # create archive for docker image
    - tar cvzf ${CI_PROJECT_DIR}/sil-studio.tgz 
        --xform s/tools/opt/ 
        --exclude=tools/SIL-studio/test_scripts 
        tools/SIL-studio

    # make images
    - ./docker/docker-build.sh 
        linux/amd64
        ""
        $IMAGE_PARENT_NAME
        $IMAGE_NAME-amd64
        studio
        sil-studio.tgz

    # make a manifest image
    - echo "making manifest"
    - docker manifest create $IMAGE_NAME $IMAGE_NAME-amd64
    - docker manifest inspect $IMAGE_NAME
    - docker manifest push 
        $IMAGE_NAME
        docker://$IMAGE_NAME

    # create an artifact with image info
    - echo "IMAGE_SILSTUDIO=$IMAGE_NAME" >> images.sil-studio.env
    - cat images*.env

img:
  <<: *image-builder
  stage: images
  image: $AWS_REGISTRY/irad/augustus/tools:ci-tools
  needs: [ image-cfs, image-ground, image-sil-studio ]
  before_script:    
    - git clone https://gitlab-ci-token:$CI_JOB_TOKEN@gitlab.maxar.com/irad/augustus/ftl
    - . ./dependencies.env
    - cd ftl
    - git fetch --all
    - git checkout $FTL_SOURCE_REF
    - cd ..
  script:
    # metadata info
    - echo "PROJECT=$PROJECT" >> /tmp/images.env
    - echo "DEPT=$DEPT" >> /tmp/images.env
    - echo "NODEGROUP=$CLUSTER" >> /tmp/images.env

    # combine all the images*env
    - cat image*.env >> /tmp/images.env
    - rm image*.env

    # add in ftl's view of the backplane
    - ./ftl/misc/scripts/backplane --config LLP3 env >> /tmp/images.env

    # stage the final images.env
    - mv /tmp/images.env .
    - cat images.env

    # create test exclusions list
    - jq -r '.software | keys[]' < tools/script/excluded_tests.json > excluded_tests.txt

  artifacts:
    paths:
      - 'image*.env'

      # artifact tests so that downstream can get them
      - tools/SIL-studio/test_scripts
      - tools/script
      - excluded_tests.txt
    when: 'always'
    expire_in: 1 month

build-board:
  rules:
    - if: '$CI_COMMIT_BRANCH == "development"'  
  stage: package
  needs: [release]
  trigger:
    project: irad/augustus/boards/zynqmp
    branch: main
    strategy: depend
  inherit:
    variables: false

